# ğŸ› ï¸ å·¥å…·è°ƒç”¨ç³»ç»Ÿ

## ğŸ“š æ¦‚è¿°

å·¥å…·è°ƒç”¨ç³»ç»Ÿæ˜¯æ™ºèƒ½Agentçš„æ ¸å¿ƒèƒ½åŠ›ï¼Œä½¿Agentèƒ½å¤Ÿè°ƒç”¨å¤–éƒ¨APIã€æ‰§è¡Œç¨‹åºã€å¤„ç†æ•°æ®ç­‰ã€‚æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»å·¥å…·ç³»ç»Ÿçš„è®¾è®¡åŸç†ã€å®ç°æ–¹æ³•å’Œæœ€ä½³å®è·µã€‚

## ğŸ—ï¸ å·¥å…·ç³»ç»Ÿæ¶æ„

### æ ¸å¿ƒç»„ä»¶è®¾è®¡
```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Union, Callable
from dataclasses import dataclass, field
from enum import Enum
import asyncio
import time
import json
import inspect
import logging
from functools import wraps

class ToolStatus(Enum):
    """å·¥å…·çŠ¶æ€"""
    AVAILABLE = "available"
    BUSY = "busy"
    ERROR = "error"
    DISABLED = "disabled"

class ToolType(Enum):
    """å·¥å…·ç±»å‹"""
    API = "api"                    # APIè°ƒç”¨
    CODE = "code"                  # ä»£ç æ‰§è¡Œ
    DATABASE = "database"            # æ•°æ®åº“æ“ä½œ
    CALCULATOR = "calculator"        # è®¡ç®—å·¥å…·
    SEARCH = "search"                # æœç´¢å·¥å…·
    FILE = "file"                    # æ–‡ä»¶æ“ä½œ
    SYSTEM = "system"                # ç³»ç»Ÿæ“ä½œ
    CUSTOM = "custom"                 # è‡ªå®šä¹‰å·¥å…·

@dataclass
class ToolParameter:
    """å·¥å…·å‚æ•°å®šä¹‰"""
    name: str
    type: str                        # string, integer, number, boolean, array, object
    description: str
    required: bool = False
    default: Any = None
    enum: List[Any] = None
    min_value: Optional[Union[int, float]] = None
    max_value: Optional[Union[int, float]] = None
    min_length: Optional[int] = None
    max_length: Optional[int] = None
    pattern: Optional[str] = None

@dataclass
class ToolResult:
    """å·¥å…·æ‰§è¡Œç»“æœ"""
    tool_name: str
    success: bool
    result: Any = None
    error: Optional[str] = None
    execution_time: float = 0.0
    metadata: Dict[str, Any] = field(default_factory=dict)
    cached: bool = False

@dataclass
class ToolSchema:
    """å·¥å…·æ¨¡å¼å®šä¹‰"""
    name: str
    description: str
    tool_type: ToolType
    parameters: List[ToolParameter] = field(default_factory=list)
    examples: List[Dict[str, Any]] = field(default_factory=list)
    timeout: float = 30.0
    retry_count: int = 3
    parallel_safe: bool = False

class BaseTool(ABC):
    """å·¥å…·åŸºç¡€æŠ½è±¡ç±»"""

    def __init__(self, name: str, description: str, tool_type: ToolType):
        self.name = name
        self.description = description
        self.tool_type = tool_type
        self.status = ToolStatus.AVAILABLE
        self.execution_count = 0
        self.total_execution_time = 0.0
        self.error_count = 0
        self.last_error: Optional[str] = None
        self.logger = logging.getLogger(f"tool.{name}")

    @abstractmethod
    async def execute(self, parameters: Dict[str, Any]) -> ToolResult:
        """æ‰§è¡Œå·¥å…·"""
        pass

    @abstractmethod
    def get_schema(self) -> ToolSchema:
        """è·å–å·¥å…·æ¨¡å¼"""
        pass

    @abstractmethod
    def validate_parameters(self, parameters: Dict[str, Any]) -> bool:
        """éªŒè¯å‚æ•°"""
        pass

    async def health_check(self) -> bool:
        """å¥åº·æ£€æŸ¥"""
        try:
            # ç®€å•çš„å¥åº·æ£€æŸ¥
            return True
        except Exception as e:
            self.logger.error(f"Health check failed: {e}")
            return False

    def get_stats(self) -> Dict[str, Any]:
        """è·å–å·¥å…·ç»Ÿè®¡"""
        return {
            'name': self.name,
            'type': self.tool_type.value,
            'status': self.status.value,
            'execution_count': self.execution_count,
            'total_execution_time': self.total_execution_time,
            'error_count': self.error_count,
            'success_rate': (self.execution_count - self.error_count) / max(self.execution_count, 1),
            'average_execution_time': self.total_execution_time / max(self.execution_count, 1),
            'last_error': self.last_error
        }

class ToolRegistry:
    """å·¥å…·æ³¨å†Œå™¨"""

    def __init__(self):
        self.tools = {}
        self.tool_categories = {}
        self.execution_history = []

    def register_tool(self, tool: BaseTool, category: str = "general") -> bool:
        """æ³¨å†Œå·¥å…·"""
        try:
            self.tools[tool.name] = tool

            if category not in self.tool_categories:
                self.tool_categories[category] = []
            self.tool_categories[category].append(tool.name)

            self.logger.info(f"Tool '{tool.name}' registered in category '{category}'")
            return True

        except Exception as e:
            self.logger.error(f"Failed to register tool '{tool.name}': {e}")
            return False

    def unregister_tool(self, tool_name: str) -> bool:
        """æ³¨é”€å·¥å…·"""
        if tool_name in self.tools:
            del self.tools[tool_name]

            # ä»åˆ†ç±»ä¸­ç§»é™¤
            for category, tools in self.tool_categories.items():
                if tool_name in tools:
                    tools.remove(tool_name)
                    break

            return True
        return False

    def get_tool(self, tool_name: str) -> Optional[BaseTool]:
        """è·å–å·¥å…·å®ä¾‹"""
        return self.tools.get(tool_name)

    def list_tools(self, category: str = None, tool_type: ToolType = None) -> List[str]:
        """åˆ—å‡ºå·¥å…·"""
        tools = []

        for tool_name, tool in self.tools.items():
            if category and tool_name not in self.tool_categories.get(category, []):
                continue
            if tool_type and tool.tool_type != tool_type:
                continue
            tools.append(tool_name)

        return tools

    def get_categories(self) -> Dict[str, List[str]]:
        """è·å–æ‰€æœ‰åˆ†ç±»"""
        return self.tool_categories.copy()

    async def execute_tool(self, tool_name: str, parameters: Dict[str, Any]) -> ToolResult:
        """æ‰§è¡Œå·¥å…·"""
        tool = self.get_tool(tool_name)
        if not tool:
            return ToolResult(
                tool_name=tool_name,
                success=False,
                error=f"Tool '{tool_name}' not found"
            )

        if tool.status != ToolStatus.AVAILABLE:
            return ToolResult(
                tool_name=tool_name,
                success=False,
                error=f"Tool '{tool_name}' is not available. Status: {tool.status.value}"
            )

        start_time = time.time()

        try:
            # éªŒè¯å‚æ•°
            if not tool.validate_parameters(parameters):
                return ToolResult(
                    tool_name=tool_name,
                    success=False,
                    error="Invalid parameters"
                )

            # æ‰§è¡Œå·¥å…·
            result = await tool.execute(parameters)
            tool.execution_count += 1

            execution_time = time.time() - start_time
            tool.total_execution_time += execution_time
            result.execution_time = execution_time

            if result.success:
                self.execution_history.append({
                    'tool_name': tool_name,
                    'parameters': parameters,
                    'success': True,
                    'execution_time': execution_time,
                    'timestamp': time.time()
                })
            else:
                tool.error_count += 1
                tool.last_error = result.error
                self.execution_history.append({
                    'tool_name': tool_name,
                    'parameters': parameters,
                    'success': False,
                    'error': result.error,
                    'execution_time': execution_time,
                    'timestamp': time.time()
                })

            return result

        except Exception as e:
            execution_time = time.time() - start_time
            tool.error_count += 1
            tool.last_error = str(e)

            return ToolResult(
                tool_name=tool_name,
                success=False,
                error=str(e),
                execution_time=execution_time
            )

    def get_execution_stats(self) -> Dict[str, Any]:
        """è·å–æ‰§è¡Œç»Ÿè®¡"""
        total_executions = len(self.execution_history)
        successful_executions = sum(1 for h in self.execution_history if h['success'])

        return {
            'total_executions': total_executions,
            'successful_executions': successful_executions,
            'failed_executions': total_executions - successful_executions,
            'success_rate': successful_executions / max(total_executions, 1),
            'registered_tools': len(self.tools),
            'tools_by_status': self._get_tools_by_status(),
            'tools_by_type': self._get_tools_by_type(),
            'most_used_tools': self._get_most_used_tools()
        }

    def _get_tools_by_status(self) -> Dict[str, int]:
        """æŒ‰çŠ¶æ€ç»Ÿè®¡å·¥å…·"""
        status_count = {}
        for tool in self.tools.values():
            status = tool.status.value
            status_count[status] = status_count.get(status, 0) + 1
        return status_count

    def _get_tools_by_type(self) -> Dict[str, int]:
        """æŒ‰ç±»å‹ç»Ÿè®¡å·¥å…·"""
        type_count = {}
        for tool in self.tools.values():
            tool_type = tool.tool_type.value
            type_count[tool_type] = type_count.get(tool_type, 0) + 1
        return type_count

    def _get_most_used_tools(self, limit: int = 10) -> List[Dict[str, Any]]:
        """è·å–æœ€å¸¸ç”¨çš„å·¥å…·"""
        tool_counts = {}

        for history in self.execution_history:
            tool_name = history['tool_name']
            tool_counts[tool_name] = tool_counts.get(tool_name, 0) + 1

        sorted_tools = sorted(tool_counts.items(), key=lambda x: x[1], reverse=True)

        return [{'tool_name': name, 'usage_count': count} for name, count in sorted_tools[:limit]]
```

## ğŸŒ å·¥å…·ç±»å‹å®ç°

### APIè°ƒç”¨å·¥å…·
```python
import aiohttp
import json
from urllib.parse import urljoin, urlparse, parse_qs

class APITool(BaseTool):
    """APIè°ƒç”¨å·¥å…·"""

    def __init__(self, name: str, base_url: str, headers: Dict[str, str] = None):
        super().__init__(name, "APIè°ƒç”¨å·¥å…·", ToolType.API)
        self.base_url = base_url.rstrip('/')
        self.headers = headers or {}
        self.session = None

    async def _ensure_session(self):
        """ç¡®ä¿sessionå­˜åœ¨"""
        if self.session is None or self.session.closed:
            self.session = aiohttp.ClientSession(headers=self.headers)

    async def execute(self, parameters: Dict[str, Any]) -> ToolResult:
        """æ‰§è¡ŒAPIè°ƒç”¨"""
        await self._ensure_session()

        method = parameters.get('method', 'GET').upper()
        endpoint = parameters.get('endpoint', '/')
        headers = parameters.get('headers', {})
        data = parameters.get('data')
        params = parameters.get('params')

        url = urljoin(self.base_url, endpoint)

        try:
            async with self.session.request(
                method=method,
                url=url,
                headers={**self.headers, **headers},
                json=data if method in ['POST', 'PUT'] else None,
                params=params
            ) as response:

                response_data = await response.json()

                return ToolResult(
                    tool_name=self.name,
                    success=response.status < 400,
                    result=response_data,
                    metadata={
                        'status_code': response.status,
                        'headers': dict(response.headers),
                        'url': url,
                        'method': method
                    }
                )

        except aiohttp.ClientError as e:
            return ToolResult(
                tool_name=self.name,
                success=False,
                error=f"HTTP error: {str(e)}"
            )
        except json.JSONDecodeError as e:
            return ToolResult(
                tool_name=self.name,
                success=False,
                error=f"JSON decode error: {str(e)}"
            )
        except Exception as e:
            return ToolResult(
                tool_name=self.name,
                success=False,
                error=f"Unexpected error: {str(e)}"
            )

    def get_schema(self) -> ToolSchema:
        """è·å–APIå·¥å…·æ¨¡å¼"""
        return ToolSchema(
            name=self.name,
            description="HTTP APIè°ƒç”¨å·¥å…·",
            tool_type=ToolType.API,
            parameters=[
                ToolParameter(
                    name="method",
                    type="string",
                    description="HTTPæ–¹æ³• (GET, POST, PUT, DELETE, PATCH)",
                    enum=["GET", "POST", "PUT", "DELETE", "PATCH"],
                    default="GET"
                ),
                ToolParameter(
                    name="endpoint",
                    type="string",
                    description="APIç«¯ç‚¹è·¯å¾„",
                    required=True
                ),
                ToolParameter(
                    name="headers",
                    type="object",
                    description="HTTPè¯·æ±‚å¤´"
                ),
                ToolParameter(
                    name="data",
                    type="object",
                    description="è¯·æ±‚ä½“æ•°æ®ï¼ˆç”¨äºPOST/PUTï¼‰"
                ),
                ToolParameter(
                    name="params",
                    type="object",
                    description="URLæŸ¥è¯¢å‚æ•°"
                )
            ],
            examples=[
                {
                    "description": "è·å–ç”¨æˆ·ä¿¡æ¯",
                    "parameters": {
                        "method": "GET",
                        "endpoint": "/api/users/123"
                    }
                },
                {
                    "description": "åˆ›å»ºç”¨æˆ·",
                    "parameters": {
                        "method": "POST",
                        "endpoint": "/api/users",
                        "data": {
                            "name": "å¼ ä¸‰",
                            "email": "zhangsan@example.com"
                        }
                    }
                }
            ]
        )

    def validate_parameters(self, parameters: Dict[str, Any]) -> bool:
        """éªŒè¯APIå‚æ•°"""
        required_params = ['endpoint']
        return all(param in parameters for param in required_params)

    async def cleanup(self):
        """æ¸…ç†èµ„æº"""
        if self.session and not self.session.closed:
            await self.session.close()

# å…·ä½“APIå·¥å…·å®ç°
class WeatherAPITool(APITool):
    """å¤©æ°”APIå·¥å…·"""

    def __init__(self, api_key: str):
        super().__init__(
            name="weather_api",
            base_url="https://api.openweathermap.org/data/2.5",
            headers={"Accept": "application/json"}
        )
        self.api_key = api_key

    async def execute(self, parameters: Dict[str, Any]) -> ToolResult:
        """æ‰§è¡Œå¤©æ°”æŸ¥è¯¢"""
        city = parameters.get('city', 'Beijing')
        units = parameters.get('units', 'metric')

        # æ„å»ºå‚æ•°
        api_params = {
            'q': city,
            'appid': self.api_key,
            'units': units
        }

        parameters['params'] = api_params
        parameters['endpoint'] = '/weather'
        parameters['method'] = 'GET'

        result = await super().execute(parameters)

        if result.success:
            weather_data = result.result
            processed_result = {
                'city': weather_data.get('name', city),
                'temperature': weather_data.get('main', {}).get('temp'),
                'description': weather_data.get('weather', [{}])[0].get('description'),
                'humidity': weather_data.get('main', {}).get('humidity'),
                'pressure': weather_data.get('main', {}).get('pressure')
            }
            result.result = processed_result

        return result

    def get_schema(self) -> ToolSchema:
        """è·å–å¤©æ°”APIæ¨¡å¼"""
        return ToolSchema(
            name=self.name,
            description="è·å–å¤©æ°”ä¿¡æ¯",
            tool_type=ToolType.API,
            parameters=[
                ToolParameter(
                    name="city",
                    type="string",
                    description="åŸå¸‚åç§°",
                    required=True
                ),
                ToolParameter(
                    name="units",
                    type="string",
                    description="æ¸©åº¦å•ä½",
                    enum=["metric", "imperial"],
                    default="metric"
                )
            ],
            examples=[
                {
                    "description": "è·å–åŒ—äº¬å¤©æ°”",
                    "parameters": {
                        "city": "Beijing",
                        "units": "metric"
                    }
                }
            ]
        )

class SearchAPITool(APITool):
    """æœç´¢APIå·¥å…·"""

    def __init__(self, search_engine: str = "google", api_key: str = None):
        super().__init__(
            name=f"{search_engine}_search",
            base_url=f"https://www.googleapis.com/customsearch/v1",
            headers={"Accept": "application/json"}
        )
        self.search_engine = search_engine
        self.api_key = api_key
        self.search_id = "your_search_engine_id"  # éœ€è¦é…ç½®

    async def execute(self, parameters: Dict[str, Any]) -> ToolResult:
        """æ‰§è¡Œæœç´¢"""
        query = parameters.get('query', '')
        num_results = min(parameters.get('num_results', 10), 10)

        search_params = {
            'key': self.api_key,
            'cx': self.search_id,
            'q': query,
            'num': num_results
        }

        parameters['params'] = search_params
        parameters['endpoint'] = '/search'
        parameters['method'] = 'GET'

        result = await super().execute(parameters)

        if result.success:
            search_data = result.result
            processed_results = []

            for item in search_data.get('items', []):
                processed_results.append({
                    'title': item.get('title', ''),
                    'snippet': item.get('snippet', ''),
                    'link': item.get('link', ''),
                    'displayLink': item.get('displayLink', '')
                })

            result.result = {
                'query': query,
                'total_results': len(processed_results),
                'results': processed_results
            }

        return result
```

### ä»£ç æ‰§è¡Œå·¥å…·
```python
import subprocess
import tempfile
import os
import sys
import uuid
import asyncio
from concurrent.futures import ThreadPoolExecutor
import traceback

class CodeExecutionTool(BaseTool):
    """ä»£ç æ‰§è¡Œå·¥å…·"""

    def __init__(self, name: str, language: str = "python"):
        super().__init__(name, f"{language}ä»£ç æ‰§è¡Œå·¥å…·", ToolType.CODE)
        self.language = language
        self.executor = ThreadPoolExecutor(max_workers=2)
        self.temp_dir = tempfile.mkdtemp()
        self.execution_timeout = 30.0

    async def execute(self, parameters: Dict[str, Any]) -> ToolResult:
        """æ‰§è¡Œä»£ç """
        code = parameters.get('code', '')
        input_data = parameters.get('input', '')

        if not code.strip():
            return ToolResult(
                tool_name=self.name,
                success=False,
                error="ä»£ç ä¸èƒ½ä¸ºç©º"
            )

        if self.language == "python":
            return await self._execute_python(code, input_data)
        elif self.language == "javascript":
            return await self._execute_javascript(code, input_data)
        else:
            return ToolResult(
                tool_name=self.name,
                success=False,
                error=f"ä¸æ”¯æŒçš„è¯­è¨€: {self.language}"
            )

    async def _execute_python(self, code: str, input_data: str) -> ToolResult:
        """æ‰§è¡ŒPythonä»£ç """
        start_time = time.time()

        try:
            # åˆ›å»ºä¸´æ—¶æ–‡ä»¶
            script_file = os.path.join(self.temp_dir, f"script_{uuid.uuid4()}.py")

            with open(script_file, 'w', encoding='utf-8') as f:
                # åŒ…è£…ä»£ç ä»¥æ”¯æŒè¾“å…¥
                wrapped_code = f"""
import sys

# å‡†å¤‡è¾“å…¥
input_data = {repr(input_data)}

if input_data:
    import io
    old_stdin = sys.stdin
    sys.stdin = io.StringIO(input_data)

try:
{code}

except Exception as e:
    import traceback
    print(f"Error: {{e}}")
    traceback.print_exc()

finally:
    if input_data:
        sys.stdin = old_stdin
"""
                f.write(wrapped_code)

            # åœ¨çº¿ç¨‹æ± ä¸­æ‰§è¡Œ
            loop = asyncio.get_event_loop()
            result, error = await loop.run_in_executor(
                self.executor,
                self._run_subprocess,
                [sys.executable, script_file]
            )

            execution_time = time.time() - start_time

            if error:
                return ToolResult(
                    tool_name=self.name,
                    success=False,
                    error=error,
                    execution_time=execution_time
                )
            else:
                return ToolResult(
                    tool_name=self.name,
                    success=True,
                    result={'output': result},
                    execution_time=execution_time
                )

        except Exception as e:
            return ToolResult(
                tool_name=self.name,
                success=False,
                error=f"æ‰§è¡Œå¤±è´¥: {str(e)}",
                execution_time=time.time() - start_time
            )
        finally:
            # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
            try:
                if os.path.exists(script_file):
                    os.remove(script_file)
            except:
                pass

    def _run_subprocess(self, cmd: List[str]) -> tuple:
        """è¿è¡Œå­è¿›ç¨‹"""
        try:
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self.execution_timeout,
                cwd=self.temp_dir
            )

            return process.stdout, process.stderr
        except subprocess.TimeoutExpired:
            return "", "æ‰§è¡Œè¶…æ—¶"
        except Exception as e:
            return "", f"è¿›ç¨‹é”™è¯¯: {str(e)}"

    async def _execute_javascript(self, code: str, input_data: str) -> ToolResult:
        """æ‰§è¡ŒJavaScriptä»£ç """
        start_time = time.time()

        try:
            script_file = os.path.join(self.temp_dir, f"script_{uuid.uuid4()}.js")

            with open(script_file, 'w', encoding='utf-8') as f:
                js_code = f"""
const input_data = {repr(input_data)};

try {{
{code}
}} catch (error) {{
    console.log('Error:', error.message);
    process.exit(1);
}}
"""
                f.write(js_code)

            # ä½¿ç”¨Node.jsæ‰§è¡Œ
            result, error = await self._run_subprocess(['node', script_file])

            execution_time = time.time() - start_time

            if error:
                return ToolResult(
                    tool_name=self.name,
                    success=False,
                    error=error,
                    execution_time=execution_time
                )
            else:
                return ToolResult(
                    tool_name=self.name,
                    success=True,
                    result={'output': result},
                    execution_time=execution_time
                )

        except Exception as e:
            return ToolResult(
                tool_name=self.name,
                success=False,
                error=f"JavaScriptæ‰§è¡Œå¤±è´¥: {str(e)}",
                execution_time=time.time() - start_time
            )
        finally:
            try:
                if os.path.exists(script_file):
                    os.remove(script_file)
            except:
                pass

    def get_schema(self) -> ToolSchema:
        """è·å–ä»£ç æ‰§è¡Œå·¥å…·æ¨¡å¼"""
        return ToolSchema(
            name=self.name,
            description=f"æ‰§è¡Œ{self.language}ä»£ç ",
            tool_type=ToolType.CODE,
            parameters=[
                ToolParameter(
                    name="code",
                    type="string",
                    description=f"{self.language}ä»£ç ",
                    required=True
                ),
                ToolParameter(
                    name="input",
                    type="string",
                    description="è¾“å…¥æ•°æ®"
                )
            ],
            examples=[
                {
                    "description": f"è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—",
                    "parameters": {
                        "code": """
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

for i in range(10):
    print(f"fib({i}) = {fibonacci(i)}")
"""
                    }
                }
            ],
            timeout=30.0
        )

    def validate_parameters(self, parameters: Dict[str, Any]) -> bool:
        """éªŒè¯ä»£ç æ‰§è¡Œå‚æ•°"""
        code = parameters.get('code', '').strip()
        return len(code) > 0

    def cleanup(self):
        """æ¸…ç†ä¸´æ—¶ç›®å½•"""
        try:
            import shutil
            shutil.rmtree(self.temp_dir)
        except:
            pass
```

### æ•°æ®åº“å·¥å…·
```python
import sqlite3
import asyncpg
from datetime import datetime, timedelta
from typing import List, Any, Dict

class DatabaseTool(BaseTool):
    """æ•°æ®åº“æ“ä½œå·¥å…·"""

    def __init__(self, name: str, connection_string: str):
        super().__init__(name, "æ•°æ®åº“æ“ä½œå·¥å…·", ToolType.DATABASE)
        self.connection_string = connection_string
        self.db_type = self._detect_db_type()
        self.connection = None

    def _detect_db_type(self) -> str:
        """æ£€æµ‹æ•°æ®åº“ç±»å‹"""
        if self.connection_string.startswith('sqlite'):
            return 'sqlite'
        elif 'postgresql' in self.connection_string:
            return 'postgresql'
        elif 'mysql' in self.connection_string:
            return 'mysql'
        else:
            return 'unknown'

    async def execute(self, parameters: Dict[str, Any]) -> ToolResult:
        """æ‰§è¡Œæ•°æ®åº“æ“ä½œ"""
        operation = parameters.get('operation', 'query')
        sql = parameters.get('sql', '')
        params = parameters.get('parameters', [])

        if not sql.strip():
            return ToolResult(
                tool_name=self.name,
                success=False,
                error="SQLè¯­å¥ä¸èƒ½ä¸ºç©º"
            )

        try:
            if self.db_type == 'sqlite':
                result = await self._execute_sqlite(operation, sql, params)
            elif self.db_type == 'postgresql':
                result = await self._execute_postgresql(operation, sql, params)
            else:
                result = ToolResult(
                    tool_name=self.name,
                    success=False,
                    error=f"ä¸æ”¯æŒçš„æ•°æ®åº“ç±»å‹: {self.db_type}"
                )

            return result

        except Exception as e:
            return ToolResult(
                tool_name=self.name,
                success=False,
                error=f"æ•°æ®åº“æ“ä½œå¤±è´¥: {str(e)}"
            )

    async def _execute_sqlite(self, operation: str, sql: str, params: List[Any]) -> ToolResult:
        """æ‰§è¡ŒSQLiteæ“ä½œ"""
        import aiosqlite

        start_time = time.time()

        try:
            async with aiosqlite.connect(self.connection_string) as conn:
                conn.row_factory = sqlite3.Row
                cursor = await conn.cursor()

                if operation.lower() == 'query':
                    await cursor.execute(sql, params)
                    rows = await cursor.fetchall()

                    result_data = [dict(row) for row in rows]

                elif operation.lower() in ['insert', 'update', 'delete']:
                    await cursor.execute(sql, params)
                    await conn.commit()
                    result_data = {'affected_rows': cursor.rowcount}

                else:
                    return ToolResult(
                        tool_name=self.name,
                        success=False,
                        error=f"ä¸æ”¯æŒçš„æ“ä½œ: {operation}"
                    )

                return ToolResult(
                    tool_name=self.name,
                    success=True,
                    result=result_data,
                    execution_time=time.time() - start_time
                )

        except Exception as e:
            return ToolResult(
                tool_name=self.name,
                success=False,
                error=f"SQLiteæ“ä½œå¤±è´¥: {str(e)}",
                execution_time=time.time() - start_time
            )

    async def _execute_postgresql(self, operation: str, sql: str, params: List[Any]) -> ToolResult:
        """æ‰§è¡ŒPostgreSQLæ“ä½œ"""
        start_time = time.time()

        try:
            conn = await asyncpg.connect(self.connection_string)

            async with conn.transaction():
                if operation.lower() == 'query':
                    result = await conn.fetch(sql, *params)
                    result_data = [dict(row) for row in result]

                elif operation.lower() in ['insert', 'update', 'delete']:
                    result = await conn.execute(sql, *params)
                    result_data = {'affected_rows': len(result)}

                else:
                    return ToolResult(
                        tool_name=self.name,
                        success=False,
                        error=f"ä¸æ”¯æŒçš„æ“ä½œ: {operation}"
                    )

                await conn.close()

                return ToolResult(
                    tool_name=self.name,
                    success=True,
                    result=result_data,
                    execution_time=time.time() - start_time
                )

        except Exception as e:
            return ToolResult(
                tool_name=self.name,
                success=False,
                error=f"PostgreSQLæ“ä½œå¤±è´¥: {str(e)}",
                execution_time=time.time() - start_time
            )

    def get_schema(self) -> ToolSchema:
        """è·å–æ•°æ®åº“å·¥å…·æ¨¡å¼"""
        return ToolSchema(
            name=self.name,
            description="æ•°æ®åº“æ“ä½œå·¥å…·",
            tool_type=ToolType.DATABASE,
            parameters=[
                ToolParameter(
                    name="operation",
                    type="string",
                    description="æ“ä½œç±»å‹ (query, insert, update, delete)",
                    enum=["query", "insert", "update", "delete"],
                    required=True
                ),
                ToolParameter(
                    name="sql",
                    type="string",
                    description="SQLè¯­å¥",
                    required=True
                ),
                ToolParameter(
                    name="parameters",
                    type="array",
                    description="SQLå‚æ•°",
                    default=[]
                )
            ],
            examples=[
                {
                    "description": "æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯",
                    "parameters": {
                        "operation": "query",
                        "sql": "SELECT * FROM users WHERE age > ?",
                        "parameters": [18]
                    }
                }
            ]
        )

    def validate_parameters(self, parameters: Dict[str, Any]) -> bool:
        """éªŒè¯æ•°æ®åº“å‚æ•°"""
        required = ['operation', 'sql']
        return all(param in parameters for param in required)
```

### è®¡ç®—å·¥å…·
```python
import math
import numpy as np
from typing import Union, List

class CalculatorTool(BaseTool):
    """è®¡ç®—å™¨å·¥å…·"""

    def __init__(self, name: str = "calculator"):
        super().__init__(name, "æ•°å­¦è®¡ç®—å™¨", ToolType.CALCULATOR)
        self.supported_operations = [
            '+', '-', '*', '/', '**', '%', 'sqrt', 'log', 'sin', 'cos', 'tan',
            'factorial', 'combination', 'permutation', 'mean', 'median', 'mode',
            'std', 'var', 'sum', 'max', 'min', 'round', 'abs'
        ]

    async def execute(self, parameters: Dict[str, Any]) -> ToolResult:
        """æ‰§è¡Œè®¡ç®—"""
        operation = parameters.get('operation', '')
        operands = parameters.get('operands', [])

        try:
            if operation == 'expression':
                return await self._evaluate_expression(parameters.get('expression', ''))
            elif operation in self.supported_operations:
                return await self._execute_operation(operation, operands)
            else:
                return ToolResult(
                    tool_name=self.name,
                    success=False,
                    error=f"ä¸æ”¯æŒçš„æ“ä½œ: {operation}"
                )

        except Exception as e:
            return ToolResult(
                tool_name=self.name,
                success=False,
                error=f"è®¡ç®—é”™è¯¯: {str(e)}"
            )

    async def _evaluate_expression(self, expression: str) -> ToolResult:
        """è®¡ç®—æ•°å­¦è¡¨è¾¾å¼"""
        # å®‰å…¨çš„è¡¨è¾¾å¼è®¡ç®—
        allowed_functions = {
            'sin': math.sin,
            'cos': math.cos,
            'tan': math.tan,
            'sqrt': math.sqrt,
            'log': math.log,
            'exp': math.exp,
            'abs': abs,
            'round': round,
            'factorial': math.factorial
        }

        allowed_constants = {
            'pi': math.pi,
            'e': math.e
        }

        # ç®€å•çš„å®‰å…¨æ£€æŸ¥
        dangerous_keywords = ['import', 'exec', 'eval', 'open', 'file']
        expression_lower = expression.lower()

        for keyword in dangerous_keywords:
            if keyword in expression_lower:
                return ToolResult(
                    tool_name=self.name,
                    success=False,
                    error="è¡¨è¾¾å¼åŒ…å«ä¸å®‰å…¨çš„å…³é”®è¯"
                )

        # æ„å»ºå®‰å…¨çš„è®¡ç®—ç¯å¢ƒ
        safe_dict = {**allowed_functions, **allowed_constants}

        try:
            # ä½¿ç”¨evalè®¡ç®—ï¼ˆåœ¨å®é™…åº”ç”¨ä¸­åº”è¯¥ä½¿ç”¨æ›´å®‰å…¨çš„æ–¹æ³•ï¼‰
            result = eval(expression, {"__builtins__": {}}, safe_dict)

            return ToolResult(
                tool_name=self.name,
                success=True,
                result={
                    'expression': expression,
                    'result': result,
                    'type': type(result).__name__
                }
            )

        except Exception as e:
            return ToolResult(
                tool_name=self.name,
                success=False,
                error=f"è¡¨è¾¾å¼è®¡ç®—å¤±è´¥: {str(e)}"
            )

    def get_schema(self) -> ToolSchema:
        """è·å–è®¡ç®—å™¨å·¥å…·æ¨¡å¼"""
        return ToolSchema(
            name=self.name,
            description="æ•°å­¦è®¡ç®—å™¨",
            tool_type=ToolType.CALCULATOR,
            parameters=[
                ToolParameter(
                    name="operation",
                    type="string",
                    description="è®¡ç®—æ“ä½œ",
                    enum=self.supported_operations + ["expression"],
                    required=True
                ),
                ToolParameter(
                    name="operands",
                    type="array",
                    description="æ“ä½œæ•°åˆ—è¡¨",
                    default=[]
                ),
                ToolParameter(
                    name="expression",
                    type="string",
                    description="æ•°å­¦è¡¨è¾¾å¼"
                )
            ],
            examples=[
                {
                    "description": "åŸºæœ¬è®¡ç®—",
                    "parameters": {
                        "operation": "+",
                        "operands": [5, 3, 2]
                    }
                }
            ]
        )

    def validate_parameters(self, parameters: Dict[str, Any]) -> bool:
        """éªŒè¯è®¡ç®—å™¨å‚æ•°"""
        operation = parameters.get('operation', '')

        if operation == 'expression':
            return 'expression' in parameters and parameters['expression'].strip()
        elif operation in self.supported_operations:
            return 'operands' in parameters and parameters['operands']
        else:
            return False
```

## ğŸ”„ å·¥å…·å‘ç°ä¸ç®¡ç†

### åŠ¨æ€å·¥å…·åŠ è½½
```python
import importlib
import inspect
import pkgutil
from pathlib import Path

class ToolLoader:
    """å·¥å…·åŠ è½½å™¨"""

    def __init__(self, tool_directory: str = "tools"):
        self.tool_directory = Path(tool_directory)
        self.loaded_tools = {}

    async def load_tools_from_directory(self, registry: ToolRegistry) -> int:
        """ä»ç›®å½•åŠ è½½å·¥å…·"""
        loaded_count = 0

        if not self.tool_directory.exists():
            self.tool_directory.mkdir(parents=True)
            return 0

        for module_info in pkgutil.iter_modules([str(self.tool_directory)]):
            module_name = module_info.name
            try:
                # åŠ¨æ€å¯¼å…¥æ¨¡å—
                module = importlib.import_module(f"{self.tool_directory.name}.{module_name}")

                # æŸ¥æ‰¾å·¥å…·ç±»
                for name, obj in inspect.getmembers(module, inspect.isclass):
                    if (issubclass(obj, BaseTool) and
                        obj is not BaseTool):

                        # å®ä¾‹åŒ–å·¥å…·
                        tool_instance = obj()

                        # æ³¨å†Œå·¥å…·
                        if registry.register_tool(tool_instance):
                            loaded_count += 1
                            self.loaded_tools[tool_instance.name] = tool_instance

            except Exception as e:
                logging.error(f"Failed to load tool module {module_name}: {e}")

        return loaded_count
```

## ğŸ“Š å·¥å…·è°ƒç”¨ç¤ºä¾‹

### å®Œæ•´çš„å·¥å…·ç³»ç»Ÿä½¿ç”¨
```python
async def tool_system_demo():
    """å·¥å…·ç³»ç»Ÿæ¼”ç¤º"""

    # åˆ›å»ºå·¥å…·æ³¨å†Œå™¨
    registry = ToolRegistry()

    # æ³¨å†Œè®¡ç®—å™¨å·¥å…·
    calculator = CalculatorTool()
    registry.register_tool(calculator, category="math")

    # æ³¨å†Œå¤©æ°”APIå·¥å…·
    weather_tool = WeatherAPITool(api_key="your_api_key")
    registry.register_tool(weather_tool, category="weather")

    # æ³¨å†Œä»£ç æ‰§è¡Œå·¥å…·
    python_executor = CodeExecutionTool("python_executor", "python")
    registry.register_tool(python_executor, category="development")

    # æµ‹è¯•è®¡ç®—å™¨
    calc_result = await registry.execute_tool(
        "calculator",
        {
            "operation": "+",
            "operands": [10, 20, 30]
        }
    )
    print("è®¡ç®—å™¨ç»“æœ:", calc_result.result)

    # æµ‹è¯•è¡¨è¾¾å¼è®¡ç®—
    expr_result = await registry.execute_tool(
        "calculator",
        {
            "operation": "expression",
            "expression": "sin(pi/4) + cos(pi/4)"
        }
    )
    print("è¡¨è¾¾å¼è®¡ç®—ç»“æœ:", expr_result.result)

    # æµ‹è¯•ä»£ç æ‰§è¡Œ
    code_result = await registry.execute_tool(
        "python_executor",
        {
            "code": """
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print([fibonacci(i) for i in range(5)])
"""
        }
    )
    print("ä»£ç æ‰§è¡Œç»“æœ:", code_result.result)

    # è·å–æ‰§è¡Œç»Ÿè®¡
    stats = registry.get_execution_stats()
    print("å·¥å…·ç³»ç»Ÿç»Ÿè®¡:", stats)

# è¿è¡Œæ¼”ç¤º
# asyncio.run(tool_system_demo())
```

## ğŸ“ æ€»ç»“

å·¥å…·è°ƒç”¨ç³»ç»Ÿæ˜¯æ‰©å±•Agentèƒ½åŠ›çš„å…³é”®æŠ€æœ¯ï¼Œæœ¬æ–‡æ¡£ä»‹ç»äº†å®Œæ•´çš„å·¥å…·ç³»ç»Ÿæ¶æ„å’Œå®ç°æ–¹æ³•ã€‚

### ğŸ¯ å…³é”®è¦ç‚¹
- **æ¨¡å—åŒ–è®¾è®¡**: æ¸…æ™°çš„å·¥å…·æŠ½è±¡å’Œæ¥å£å®šä¹‰
- **å¤šç±»å‹æ”¯æŒ**: APIã€ä»£ç ã€æ•°æ®åº“ã€è®¡ç®—ç­‰å¤šç§å·¥å…·ç±»å‹
- **å®‰å…¨æ‰§è¡Œ**: ä»£ç æ‰§è¡Œçš„æ²™ç®±ç¯å¢ƒå’Œå®‰å…¨æ£€æŸ¥
- **æ€§èƒ½ä¼˜åŒ–**: ç¼“å­˜æœºåˆ¶å’Œå¹¶è¡Œæ‰§è¡Œæ”¯æŒ
- **åŠ¨æ€åŠ è½½**: æ”¯æŒè¿è¡Œæ—¶å·¥å…·åŠ è½½å’Œçƒ­æ›´æ–°

### ğŸš€ å®ç°ç‰¹è‰²
- **å¼‚æ­¥æ‰§è¡Œ**: æ‰€æœ‰å·¥å…·æ“ä½œéƒ½æ”¯æŒå¼‚æ­¥æ‰§è¡Œ
- **ç»“æœç¼“å­˜**: æ™ºèƒ½ç¼“å­˜æœºåˆ¶æé«˜æ€§èƒ½
- **é”™è¯¯å¤„ç†**: å®Œå–„çš„å¼‚å¸¸å¤„ç†å’Œé”™è¯¯æ¢å¤
- **ç»Ÿè®¡åˆ†æ**: è¯¦ç»†çš„æ‰§è¡Œç»Ÿè®¡å’Œæ€§èƒ½ç›‘æ§
- **å®‰å…¨æ²™ç®±**: ä»£ç æ‰§è¡Œçš„å®‰å…¨ç¯å¢ƒ

### ğŸ”„ ä¸‹ä¸€æ­¥
- å­¦ä¹ [RAGé›†æˆAgent](04-RAGç³»ç»Ÿ.md)
- æŒæ¡[ä¸Šä¸‹æ–‡ç®¡ç†](05-ä¸Šä¸‹æ–‡ç®¡ç†.md)
- äº†è§£[å†³ç­–è§„åˆ’](06-å†³ç­–è§„åˆ’.md)
- æ¢ç´¢[Agentæ€§èƒ½ä¼˜åŒ–](../deployment/04-æ€§èƒ½ç›‘æ§.md)
