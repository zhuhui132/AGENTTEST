# ðŸ† Agentæµ‹è¯•æœ€ä½³å®žè·µ

## ðŸŽ¯ å®žè·µæ¦‚è§ˆ

Agentæµ‹è¯•æœ€ä½³å®žè·µæ˜¯åŸºäºŽå¤§é‡é¡¹ç›®ç»éªŒæ€»ç»“çš„è§„èŒƒåŒ–æ–¹æ³•è®ºï¼Œæ¶µç›–æµ‹è¯•ç­–ç•¥ã€å®žæ–½æµç¨‹ã€å·¥å…·ä½¿ç”¨ã€å›¢é˜Ÿåä½œç­‰å„ä¸ªæ–¹é¢ï¼Œå¸®åŠ©å›¢é˜Ÿé«˜æ•ˆã€ç§‘å­¦åœ°å¼€å±•Agentæµ‹è¯•å·¥ä½œã€‚

## ðŸ§ª æµ‹è¯•ç­–ç•¥æœ€ä½³å®žè·µ

### ðŸ“‹ é£Žé™©é©±åŠ¨çš„æµ‹è¯•ä¼˜å…ˆçº§

#### 1. é£Žé™©è¯„ä¼°çŸ©é˜µ
```python
class TestPrioritization:
    """æµ‹è¯•ä¼˜å…ˆçº§æœ€ä½³å®žè·µ"""

    RISK_MATRIX = {
        # é«˜é£Žé™©ã€é«˜å½±å“ - æœ€é«˜ä¼˜å…ˆçº§
        "P0": {
            "criteria": [
                "å®‰å…¨ç›¸å…³åŠŸèƒ½",
                "æ ¸å¿ƒä¸šåŠ¡æµç¨‹",
                "ç”¨æˆ·è®¤è¯æŽˆæƒ",
                "æ•°æ®ä¸€è‡´æ€§ä¿è¯",
                "æ”¯ä»˜ç›¸å…³åŠŸèƒ½"
            ],
            "test_frequency": "æ¯æ¬¡æž„å»º",
            "automation_level": "100%",
            "coverage_target": "100%",
            "examples": [
                "ç”¨æˆ·ç™»å½•è®¤è¯",
                "æ”¯ä»˜æµç¨‹å¤„ç†",
                "æ•°æ®åŠ å¯†è§£å¯†",
                "æƒé™éªŒè¯"
            ]
        },

        # ä¸­é«˜é£Žé™©ã€ä¸­é«˜å½±å“ - é«˜ä¼˜å…ˆçº§
        "P1": {
            "criteria": [
                "ä¸»è¦åŠŸèƒ½æ¨¡å—",
                "æ€§èƒ½å…³é”®è·¯å¾„",
                "ç”¨æˆ·ä½“éªŒç›¸å…³",
                "é›†æˆæŽ¥å£",
                "æ•°æ®å¯¼å…¥å¯¼å‡º"
            ],
            "test_frequency": "æ¯æ—¥æž„å»º",
            "automation_level": "90%",
            "coverage_target": "95%",
            "examples": [
                "æœç´¢åŠŸèƒ½",
                "æ–‡ä»¶ä¸Šä¼ ä¸‹è½½",
                "æ¶ˆæ¯æŽ¨é€",
                "æ•°æ®åŒæ­¥"
            ]
        },

        # ä¸­é£Žé™©ã€ä¸­å½±å“ - ä¸­ç­‰ä¼˜å…ˆçº§
        "P2": {
            "criteria": [
                "è¾…åŠ©åŠŸèƒ½",
                "é…ç½®ç®¡ç†",
                "æ—¥å¿—ç›‘æŽ§",
                "æŠ¥è¡¨ç”Ÿæˆ",
                "æ‰¹é‡æ“ä½œ"
            ],
            "test_frequency": "æ¯å‘¨æž„å»º",
            "automation_level": "70%",
            "coverage_target": "80%",
            "examples": [
                "ç³»ç»Ÿé…ç½®",
                "æ—¥å¿—æŸ¥çœ‹",
                "æ•°æ®å¤‡ä»½",
                "ç”¨æˆ·è®¾ç½®"
            ]
        },

        # ä½Žé£Žé™©ã€ä½Žå½±å“ - ä½Žä¼˜å…ˆçº§
        "P3": {
            "criteria": [
                "è¾¹ç¼˜åœºæ™¯",
                "æ–‡æ¡£åŠŸèƒ½",
                "ç•Œé¢ç¾ŽåŒ–",
                "è°ƒè¯•åŠŸèƒ½",
                "betaåŠŸèƒ½"
            ],
            "test_frequency": "æ¯ç‰ˆæœ¬å‘å¸ƒ",
            "automation_level": "30%",
            "coverage_target": "60%",
            "examples": [
                "å¸®åŠ©æ–‡æ¡£",
                "ä¸»é¢˜åˆ‡æ¢",
                "ç‰ˆæœ¬ä¿¡æ¯",
                "è°ƒè¯•æ¨¡å¼"
            ]
        }
    }
```

#### 2. åŠ¨æ€ä¼˜å…ˆçº§è°ƒæ•´
```python
class DynamicPriorityAdjuster:
    """åŠ¨æ€ä¼˜å…ˆçº§è°ƒæ•´å™¨"""

    def __init__(self):
        self.priority_factors = {
            "bug_frequency": 0.3,      # åŽ†å²bugé¢‘çŽ‡
            "user_complaints": 0.25,   # ç”¨æˆ·æŠ•è¯‰çŽ‡
            "business_impact": 0.2,    # ä¸šåŠ¡å½±å“åº¦
            "change_frequency": 0.15,   # ä»£ç å˜æ›´é¢‘çŽ‡
            "complexity": 0.1           # ä»£ç å¤æ‚åº¦
        }

    def calculate_priority_score(self, component: Dict) -> float:
        """è®¡ç®—ç»„ä»¶çš„ä¼˜å…ˆçº§è¯„åˆ†"""
        score = 0

        for factor, weight in self.priority_factors.items():
            factor_value = component.get(factor, 0)
            score += factor_value * weight

        return score

    def adjust_test_priority(self, component: str, current_priority: str,
                           new_score: float) -> str:
        """æ ¹æ®è¯„åˆ†è°ƒæ•´æµ‹è¯•ä¼˜å…ˆçº§"""
        if new_score > 0.8:
            return "P0"  # æå‡åˆ°æœ€é«˜ä¼˜å…ˆçº§
        elif new_score > 0.6:
            return "P1"  # æå‡åˆ°é«˜ä¼˜å…ˆçº§
        elif new_score > 0.4:
            return "P2"  # ä¿æŒä¸­ç­‰ä¼˜å…ˆçº§
        else:
            return "P3"  # é™ä½Žåˆ°ä½Žä¼˜å…ˆçº§
```

### ðŸŽ¯ åŸºäºŽç”¨æˆ·ä»·å€¼çš„æµ‹è¯•

#### ç”¨æˆ·æ—…ç¨‹æµ‹è¯•
```python
class UserJourneyTesting:
    """ç”¨æˆ·æ—…ç¨‹æµ‹è¯•æœ€ä½³å®žè·µ"""

    USER_JOURNEYS = {
        "æ–°ç”¨æˆ·æ³¨å†Œæµç¨‹": {
            "steps": [
                "è®¿é—®é¦–é¡µ",
                "ç‚¹å‡»æ³¨å†Œ",
                "å¡«å†™è¡¨å•",
                "é‚®ç®±éªŒè¯",
                "å®Œå–„èµ„æ–™",
                "é¦–æ¬¡ç™»å½•"
            ],
            "success_criteria": {
                "completion_rate": "> 90%",
                "avg_time": "< 3åˆ†é’Ÿ",
                "drop_off_rate": "< 10%"
            }
        },

        "æ ¸å¿ƒåŠŸèƒ½ä½¿ç”¨æµç¨‹": {
            "steps": [
                "ç”¨æˆ·ç™»å½•",
                "æµè§ˆåŠŸèƒ½",
                "ä½¿ç”¨æ ¸å¿ƒåŠŸèƒ½",
                "ä¿å­˜ç»“æžœ",
                "åˆ†äº«ç»“æžœ"
            ],
            "success_criteria": {
                "success_rate": "> 95%",
                "response_time": "< 2s",
                "user_satisfaction": "> 4.0/5"
            }
        }
    }

    def create_journey_tests(self, journey_name: str) -> List[Dict]:
        """åˆ›å»ºç”¨æˆ·æ—…ç¨‹æµ‹è¯•ç”¨ä¾‹"""
        journey = self.USER_JOURNEYS[journey_name]
        tests = []

        for i, step in enumerate(journey["steps"]):
            tests.append({
                "test_id": f"journey_{journey_name}_step_{i+1}",
                "description": f"æµ‹è¯•{step}æ­¥éª¤",
                "priority": "P0" if i < len(journey["steps"]) // 2 else "P1",
                "type": "journey_test",
                "dependencies": journey["steps"][:i],
                "expected_outcome": step
            })

        return tests
```

## ðŸ”§ å·¥å…·ä½¿ç”¨æœ€ä½³å®žè·µ

### ðŸ“Š æµ‹è¯•æ•°æ®ç®¡ç†

#### æµ‹è¯•æ•°æ®å·¥åŽ‚æ¨¡å¼
```python
class TestDataFactory:
    """æµ‹è¯•æ•°æ®å·¥åŽ‚"""

    @staticmethod
    def create_user(**overrides):
        """åˆ›å»ºæµ‹è¯•ç”¨æˆ·æ•°æ®"""
        defaults = {
            "id": f"user_{uuid.uuid4().hex[:8]}",
            "name": "æµ‹è¯•ç”¨æˆ·",
            "email": f"test_{uuid.uuid4().hex[:8]}@example.com",
            "age": 25,
            "role": "user",
            "status": "active"
        }
        defaults.update(overrides)
        return User(**defaults)

    @staticmethod
    def create_conversation_history(user_id: str, message_count: int = 5):
        """åˆ›å»ºå¯¹è¯åŽ†å²æ•°æ®"""
        return [
            {
                "role": "user" if i % 2 == 0 else "assistant",
                "content": f"æµ‹è¯•æ¶ˆæ¯{i}",
                "timestamp": datetime.now().isoformat()
            }
            for i in range(message_count)
        ]
```

#### æµ‹è¯•çŽ¯å¢ƒéš”ç¦»
```python
class TestEnvironmentManager:
    """æµ‹è¯•çŽ¯å¢ƒç®¡ç†"""

    ENVIRONMENTS = {
        "development": {
            "purpose": "å¿«é€Ÿè¿­ä»£ã€è°ƒè¯•æ”¯æŒ",
            "data_source": "mock",
            "scale": "single_instance",
            "monitoring": "basic"
        },
        "testing": {
            "purpose": "åŠŸèƒ½éªŒè¯ã€é›†æˆæµ‹è¯•",
            "data_source": "staging",
            "scale": "small_cluster",
            "monitoring": "standard"
        },
        "staging": {
            "purpose": "æ€§èƒ½æµ‹è¯•ã€ç”¨æˆ·éªŒæ”¶",
            "data_source": "anonymized_production",
            "scale": "production_like",
            "monitoring": "comprehensive"
        },
        "production": {
            "purpose": "çœŸå®žæœåŠ¡",
            "data_source": "production",
            "scale": "auto_scaling",
            "monitoring": "full"
        }
    }
```

### ðŸ§ª æ™ºèƒ½æµ‹è¯•ç”Ÿæˆ

#### åŸºäºŽä»£ç åˆ†æžçš„æµ‹è¯•ç”Ÿæˆ
```python
class IntelligentTestGenerator:
    """æ™ºèƒ½æµ‹è¯•ç”Ÿæˆå™¨"""

    def __init__(self):
        self.code_analyzer = CodeAnalyzer()
        self.pattern_matcher = TestPatternMatcher()

    def generate_test_cases(self, function_code: str) -> List[Dict]:
        """åŸºäºŽä»£ç åˆ†æžç”Ÿæˆæµ‹è¯•ç”¨ä¾‹"""
        analysis = self.code_analyzer.analyze(function_code)
        test_cases = []

        # è¾¹ç•Œå€¼æµ‹è¯•
        test_cases.extend(self.generate_boundary_tests(analysis))

        # ç­‰ä»·ç±»æµ‹è¯•
        test_cases.extend(self.generate_equivalence_tests(analysis))

        # å¼‚å¸¸å¤„ç†æµ‹è¯•
        test_cases.extend(self.generate_exception_tests(analysis))

        # æ€§èƒ½æµ‹è¯•
        test_cases.extend(self.generate_performance_tests(analysis))

        return test_cases
```

## ðŸ”„ CI/CDé›†æˆæœ€ä½³å®žè·µ

### ðŸš€ æŒç»­é›†æˆæµæ°´çº¿

#### å¤šé˜¶æ®µæµ‹è¯•æµæ°´çº¿
```yaml
# .github/workflows/agent-testing.yml
name: Agent Testing Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  # é˜¶æ®µ1: ä»£ç è´¨é‡æ£€æŸ¥
  code-quality:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Code formatting check
        run: black --check src/ tests/

      - name: Linting
        run: flake8 src/ tests/

      - name: Type checking
        run: mypy src/

      - name: Security scan
        run: bandit -r src/

  # é˜¶æ®µ2: å•å…ƒæµ‹è¯•
  unit-tests:
    runs-on: ubuntu-latest
    needs: code-quality
    strategy:
      matrix:
        python-version: [3.8, 3.9, '3.10', 3.11]

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Run unit tests
        run: |
          pytest tests/unit/ \
            --cov=src \
            --cov-report=xml \
            --cov-report=html \
            --junitxml=unit-test-results.xml \
            -v

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
```

### ðŸ“Š æµ‹è¯•æŠ¥å‘Šä¸Žå‘Šè­¦

#### è‡ªåŠ¨åŒ–æµ‹è¯•æŠ¥å‘Š
```python
class TestReportGenerator:
    """æµ‹è¯•æŠ¥å‘Šç”Ÿæˆå™¨"""

    def generate_comprehensive_report(self, test_results: Dict) -> Dict:
        """ç”Ÿæˆç»¼åˆæµ‹è¯•æŠ¥å‘Š"""
        report = {
            "summary": self._generate_summary(test_results),
            "quality_metrics": self._calculate_quality_metrics(test_results),
            "performance_metrics": self._calculate_performance_metrics(test_results),
            "trend_analysis": self._analyze_trends(test_results),
            "recommendations": self._generate_recommendations(test_results),
            "coverage_analysis": self._analyze_coverage(test_results)
        }

        return report
```

## ðŸ‘¥ å›¢é˜Ÿåä½œæœ€ä½³å®žè·µ

### ðŸ“‹ æµ‹è¯•å›¢é˜Ÿç»„ç»‡

#### è§’è‰²ä¸ŽèŒè´£
```python
class TestingRoles:
    """æµ‹è¯•å›¢é˜Ÿè§’è‰²å®šä¹‰"""

    ROLES = {
        "æµ‹è¯•æž¶æž„å¸ˆ": {
            "responsibilities": [
                "åˆ¶å®šæµ‹è¯•ç­–ç•¥å’Œæ–¹æ³•è®º",
                "è®¾è®¡æµ‹è¯•æž¶æž„å’Œæ¡†æž¶",
                "æŠ€æœ¯é€‰åž‹å’Œå·¥å…·è¯„ä¼°",
                "æµ‹è¯•å›¢é˜ŸæŠ€æœ¯æŒ‡å¯¼"
            ],
            "required_skills": [
                "æ·±å…¥çš„æµ‹è¯•ç†è®ºçŸ¥è¯†",
                "ä¸°å¯Œçš„é¡¹ç›®ç»éªŒ",
                "æž¶æž„è®¾è®¡èƒ½åŠ›",
                "æŠ€æœ¯é¢†å¯¼èƒ½åŠ›"
            ],
            "deliverables": [
                "æµ‹è¯•ç­–ç•¥æ–‡æ¡£",
                "æµ‹è¯•æž¶æž„è®¾è®¡",
                "æŠ€æœ¯é€‰åž‹æŠ¥å‘Š",
                "å›¢é˜ŸåŸ¹è®­è®¡åˆ’"
            ]
        },

        "æµ‹è¯•å¼€å‘å·¥ç¨‹å¸ˆ": {
            "responsibilities": [
                "å¼€å‘æµ‹è¯•æ¡†æž¶å’Œå·¥å…·",
                "å®žçŽ°è‡ªåŠ¨åŒ–æµ‹è¯•ç”¨ä¾‹",
                "ç»´æŠ¤æµ‹è¯•åŸºç¡€è®¾æ–½",
                "ä¼˜åŒ–æµ‹è¯•æ‰§è¡Œæ•ˆçŽ‡"
            ],
            "required_skills": [
                "ç¼–ç¨‹èƒ½åŠ›ï¼ˆPython/Javaç­‰ï¼‰",
                "æµ‹è¯•æ¡†æž¶ä½¿ç”¨ç»éªŒ",
                "CI/CDå·¥å…·ä½¿ç”¨",
                "æ•°æ®åº“å’Œç³»ç»ŸçŸ¥è¯†"
            ],
            "deliverables": [
                "è‡ªåŠ¨åŒ–æµ‹è¯•ä»£ç ",
                "æµ‹è¯•æ¡†æž¶",
                "å·¥å…·é“¾é›†æˆ",
                "æ€§èƒ½æµ‹è¯•è„šæœ¬"
            ]
        }
    }
```

### ðŸ”„ åä½œæµç¨‹

#### æµ‹è¯•åä½œå·¥ä½œæµ
```python
class TestingWorkflow:
    """æµ‹è¯•åä½œå·¥ä½œæµ"""

    WORKFLOW_STAGES = {
        "éœ€æ±‚åˆ†æžé˜¶æ®µ": {
            "participants": ["äº§å“ç»ç†", "æµ‹è¯•åˆ†æžå¸ˆ", "å¼€å‘å·¥ç¨‹å¸ˆ"],
            "activities": [
                "ç†è§£åŠŸèƒ½éœ€æ±‚",
                "è¯†åˆ«æµ‹è¯•è¦ç‚¹",
                "è¯„ä¼°æµ‹è¯•é£Žé™©",
                "åˆ¶å®šæµ‹è¯•è®¡åˆ’"
            ],
            "deliverables": [
                "éœ€æ±‚åˆ†æžæŠ¥å‘Š",
                "æµ‹è¯•é£Žé™©è¯„ä¼°",
                "åˆæ­¥æµ‹è¯•è®¡åˆ’"
            ],
            "timeline": "1-2å¤©"
        },

        "æµ‹è¯•è®¾è®¡é˜¶æ®µ": {
            "participants": ["æµ‹è¯•åˆ†æžå¸ˆ", "æµ‹è¯•æž¶æž„å¸ˆ"],
            "activities": [
                "è¯¦ç»†æµ‹è¯•ç”¨ä¾‹è®¾è®¡",
                "æµ‹è¯•æ•°æ®å‡†å¤‡",
                "æµ‹è¯•çŽ¯å¢ƒè§„åˆ’",
                "è‡ªåŠ¨åŒ–ç­–ç•¥åˆ¶å®š"
            ],
            "deliverables": [
                "è¯¦ç»†æµ‹è¯•ç”¨ä¾‹",
                "æµ‹è¯•æ•°æ®æ¸…å•",
                "çŽ¯å¢ƒé…ç½®æ–¹æ¡ˆ",
                "è‡ªåŠ¨åŒ–å®žçŽ°æ–¹æ¡ˆ"
            ],
            "timeline": "2-3å¤©"
        }
    }
```

## ðŸ“š æŒç»­å­¦ä¹ ä¸Žæ”¹è¿›

### ðŸŽ¯ æŠ€èƒ½æå‡è·¯å¾„

#### æµ‹è¯•å·¥ç¨‹å¸ˆæˆé•¿è·¯å¾„
```python
class SkillDevelopmentPath:
    """æµ‹è¯•å·¥ç¨‹å¸ˆæŠ€èƒ½å‘å±•è·¯å¾„"""

    SKILL_PATHS = {
        "åˆçº§æµ‹è¯•å·¥ç¨‹å¸ˆ": {
            "duration": "0-2å¹´",
            "core_skills": [
                "åŸºç¡€æµ‹è¯•ç†è®º",
                "æµ‹è¯•ç”¨ä¾‹è®¾è®¡",
                "ç¼ºé™·ç®¡ç†æµç¨‹",
                "åŸºç¡€è‡ªåŠ¨åŒ–"
            ],
            "learning_resources": [
                "è½¯ä»¶æµ‹è¯•åŸºç¡€è¯¾ç¨‹",
                "æµ‹è¯•ç”¨ä¾‹è®¾è®¡æ–¹æ³•",
                "ç¼ºé™·ç®¡ç†å·¥å…·ä½¿ç”¨",
                "Python/JavaåŸºç¡€ç¼–ç¨‹"
            ],
            "certifications": [
                "ISTQB Foundation Level",
                "è½¯ä»¶æµ‹è¯•å·¥ç¨‹å¸ˆè®¤è¯"
            ],
            "next_level": "ä¸­çº§æµ‹è¯•å·¥ç¨‹å¸ˆ"
        }
    }
```

### ðŸ“ˆ çŸ¥è¯†ç®¡ç†ä½“ç³»

#### æµ‹è¯•çŸ¥è¯†åº“å»ºè®¾
```python
class KnowledgeManagement:
    """æµ‹è¯•çŸ¥è¯†ç®¡ç†ç³»ç»Ÿ"""

    KNOWLEDGE_CATEGORIES = {
        "æµ‹è¯•ç†è®º": {
            "subcategories": [
                "æµ‹è¯•åŸºç¡€æ¦‚å¿µ",
                "æµ‹è¯•è®¾è®¡æ–¹æ³•",
                "æµ‹è¯•ç±»åž‹åˆ†ç±»",
                "è´¨é‡æ¨¡åž‹"
            ],
            "content_types": [
                "ç†è®ºæ–‡æ¡£",
                "æœ€ä½³å®žè·µ",
                "æ¡ˆä¾‹åˆ†æž",
                "æ ‡å‡†è§„èŒƒ"
            ]
        }
    }
```

## ðŸŽ¯ è´¨é‡ä¿è¯æœ€ä½³å®žè·µ

### ðŸ“‹ ä»£ç è´¨é‡æ ‡å‡†

#### æµ‹è¯•ä»£ç è´¨é‡æ£€æŸ¥
```python
class TestCodeQuality:
    """æµ‹è¯•ä»£ç è´¨é‡æ ‡å‡†"""

    QUALITY_STANDARDS = {
        "ä»£ç è¦†ç›–çŽ‡": {
            "unit_tests": {
                "minimum": 80,
                "target": 90,
                "excellent": 95
            },
            "integration_tests": {
                "minimum": 60,
                "target": 75,
                "excellent": 85
            },
            "overall": {
                "minimum": 70,
                "target": 85,
                "excellent": 90
            }
        }
    }
```

### ðŸ” æŒç»­æ”¹è¿›æœºåˆ¶

#### æµ‹è¯•æ•ˆæžœè¯„ä¼°
```python
class ContinuousImprovement:
    """æŒç»­æ”¹è¿›æœºåˆ¶"""

    def evaluate_test_effectiveness(self, test_metrics: Dict,
                                 production_metrics: Dict) -> Dict:
        """è¯„ä¼°æµ‹è¯•æ•ˆæžœ"""
        effectiveness_score = 0

        # åŸºäºŽç”Ÿäº§ç¼ºé™·çŽ‡è¯„ä¼°
        production_defect_rate = production_metrics.get("defect_rate", 0)
        if production_defect_rate < 0.01:
            effectiveness_score += 30
        elif production_defect_rate < 0.05:
            effectiveness_score += 20
        else:
            effectiveness_score += 10

        return {
            "effectiveness_score": effectiveness_score,
            "grade": self._get_effectiveness_grade(effectiveness_score),
            "improvement_areas": self._identify_improvement_areas(effectiveness_score)
        }
```

---

*è¿™äº›æœ€ä½³å®žè·µåŸºäºŽå®žé™…é¡¹ç›®ç»éªŒæ€»ç»“ï¼Œéœ€è¦æ ¹æ®å…·ä½“é¡¹ç›®æƒ…å†µè¿›è¡Œè°ƒæ•´å’Œåº”ç”¨*
