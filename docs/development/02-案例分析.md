# 🎯 案例分析：如何扩展 AgentTest

以下案例覆盖三个常见需求，展示从需求评估到实现与验证的完整路径。每个案例均附带“关键文件”“测试要点”和“常见坑”。

---

## 案例一：接入天气查询工具

**目标**：允许 Agent 回答“明天北京天气如何？”之类的问题。

### 实施步骤
1. **编写工具**（示例使用开放天气 API 或 Mock 数据）
```python
   # src/tools/weather.py
   import httpx
   from src.core.interfaces import BaseTool
   from src.core.types import ToolResult

   class WeatherTool(BaseTool):
       async def execute(self, parameters, config=None) -> ToolResult:
           city = parameters.get("city")
           if not city:
               raise ValueError("city 参数必填")

           async with httpx.AsyncClient(timeout=5) as client:
               resp = await client.get("https://api.xxx/weather", params={"q": city})
               resp.raise_for_status()
               data = resp.json()

           return ToolResult(
               tool_name="weather",
               success=True,
               result={"city": city, "temperature": data["temp"], "summary": data["text"]},
           )

       def get_schema(self):
           return {
               "type": "function",
               "function": {
                   "name": "weather",
                   "description": "查询城市天气",
                   "parameters": {
                       "type": "object",
                       "properties": {"city": {"type": "string"}},
                       "required": ["city"],
                   },
               },
           }
   ```
2. **注册工具**：在自定义初始化逻辑中执行
```python
   from src.utils.tools import ToolSystem
   from src.tools.weather import WeatherTool

   tool_system = ToolSystem()
   await tool_system.register_tool("weather", WeatherTool())
   ```
3. **修改 Agent 的工具规划**：在 `_plan_tool_usage` 中识别“天气/气温”关键词，构造调用参数。

### 测试要点
- 单测：验证工具参数校验、HTTP 错误处理。
- 集成测试：构造“北京天气”问句，检查 Agent 是否调用工具并在响应中引用结果。
- 限流：补充错误兜底（API 不可用时返回提示）。

### 常见问题
- 忽略超时导致对话阻塞 → 为 HTTP 客户端设置 timeout。
- 工具返回 JSON 过大 → 只保留必要字段，避免响应冗长。

---

## 案例二：将记忆系统改为 Redis 持久化

**目标**：在多实例部署下共享记忆条目。

### 实施步骤
1. **实现自定义 MemorySystem**
```python
   # src/memory/redis_memory.py
   import json
   import aioredis
   from datetime import datetime
   from src.core.types import MemoryItem, MemoryType
   from src.core.interfaces import BaseMemory

   class RedisMemory(BaseMemory):
       def __init__(self, url: str):
           self._redis = aioredis.from_url(url, decode_responses=True)

       async def add_memory(self, content, importance=1.0, metadata=None, *, memory_type=MemoryType.EPISODIC):
           item = MemoryItem(content=content.strip(), importance=float(importance), metadata=metadata or {}, memory_type=memory_type)
           await self._redis.hset("memories", item.id, json.dumps(item.__dict__, default=str))
           return item.id

       async def retrieve(self, query, limit=5, memory_type=None):
           if not query:
               return []
           all_items = [MemoryItem(**json.loads(v)) for v in (await self._redis.hvals("memories"))]
           # 可重用现有评分函数
           return sorted(all_items, key=lambda x: query.lower() in x.content.lower(), reverse=True)[:limit]
       # 其他接口略 …
   ```
2. **在 Agent 初始化时注入**：
```python
   from src.agents.agent import IntelligentAgent
   from src.memory.redis_memory import RedisMemory

   agent = IntelligentAgent(memory_system=RedisMemory("redis://127.0.0.1:6379/0"))
   ```
3. **配置化**：在 `config/` 中增加 redis 地址，结合 `ConfigManager` 读取。

### 测试要点
- 单测：使用 `fakeredis` 或本地 Redis 进行 CRUD 测试。
- 压力测试：导入 1~2 万条记忆，验证检索性能与资源消耗。
- 兼容性：确保 `MemoryType` 字段序列化/反序列化正确。

### 常见问题
- 未处理网络波动 → 建议增加重试或降级策略。
- JSON 序列化 datetime → 使用 `default=str` 或自定义编码器。

---

## 案例三：自定义上下文摘要策略

**目标**：在生成响应时更突出用户的“任务目标”和“约束条件”。

### 实施步骤
1. **继承 ContextManager**
```python
   from src.utils.context import ContextManager
   from src.core.types import AgentMessage

   class TaskAwareContext(ContextManager):
       def _summarize(self, messages: list[AgentMessage]) -> str:
           recent = super()._summarize(messages)
           goals = [m.content for m in messages if "目标" in m.content][-1:]  # 简单示例
           limits = [m.content for m in messages if "不要" in m.content][-1:]
           extra = []
           if goals:
               extra.append(f"当前目标：{goals[-1]}")
           if limits:
               extra.append(f"注意约束：{limits[-1]}")
           return recent + (" \n" + " \n".join(extra) if extra else "")
   ```
2. **在 Agent 中注入**
```python
   agent = IntelligentAgent(context_manager=TaskAwareContext())
   ```
3. **更新文档**：在 `docs/guides/04-技术实现指南.md` 中记录自定义要点。

### 测试要点
- 单测：构造带“目标/约束”关键词的历史记录，确认摘要输出。
- 手动验证：运行示例，对 Agent 提供多轮指令，观察响应内容是否包含目标提示。
- 回归：确保默认上下文行为仍然可选使用（可通过配置开关控制）。

### 常见问题
- 摘要过长导致 Token 超限 → 在实现中限制附加内容长度。
- 关键词匹配过于简单 → 可引入 NLP（如 spaCy）做意图抽取。

---

## 实践清单

- [ ] 每次扩展前确认是否需要更新测试/文档/配置
- [ ] 新增模块必须有最小示例或单测，否则评审时需要额外说明
- [ ] 修改公共接口后同步更新 `api/*.md`
- [ ] 影响用户流程的改动须在 `guides/05-综合总结.md` 记录

> 如有新的实践案例，欢迎在 Issue 中按“背景 → 解决方案 → 验证 → 经验”格式提交，共同完善文档。
